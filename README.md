# SG16 Meeting Summaries

SG16 meetings are typically held on Wednesdays from 3:30pm-5:00pm EST5EDT4 on the 2nd
and 4th weeks of each month, but scheduling conflicts or other time pressures sometimes
force alternative scheduling.  Meeting invitations are sent to the mailing list and
prior attendees.

The next SG16 meeting is scheduled for Wednesday, March 25th 2020, from 19:30-21:00 UTC (3:30-5:00pm EDT).

- [March 11th, 2020](#march-11th-2020)
- [February 26th, 2020](#february-26th-2020)
- [February 5th, 2020](#february-5th-2020)
- [January 22nd, 2020](#january-22nd-2020)
- [January 8th, 2020](#january-8th-2020)
- [December 11th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#december-11th-2019)
- [November 20th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#november-20th-2019)
- [October 23rd, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#october-23rd-2019)
- [October 9th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#october-9th-2019)
- [September 25th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#september-25th-2019)
- [September 4th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#september-4th-2019)
- [August 21st, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#august-21st-2019)
- [July 31st, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#july-31st-2019)
- [June 26th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#june-26th-2019)
- [June 12th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#june-12th-2019)
- [May 22nd, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#may-22nd-2019)
- [May 15th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#may-15th-2019)
- [April 24th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#april-24th-2019)
- [April 10th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#april-10th-2019)
- [March 27th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#march-27th-2019)
- [March 13th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#march-13th-2019)
- [February 13th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#february-13th-2019)
- [January 23rd, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#january-23rd-2019)
- [January 9th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#january-9th-2019)
- [December 19th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-19th-2018)
- [December 5th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-5th-2018)
- [October 17th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-17th-2018)
- [October 3rd, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-3rd-2018)
- [August 29th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#august-29th-2018)
- [July 25th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-25th-2018)
- [July 11th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-11th-2018)
- [June 20th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-20th-2018)
- [May 30th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-30th-2018)
- [May 16th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-16th-2018)
- [April 25th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-25th-2018)
- [April 11th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-11th-2018)
- [March 28th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-28th-2018)
- [Prior std-text-wg meetings](#prior-std-text-wg-meetings)


# March 11th, 2020

## Draft agenda:
- Meet and greet for SG16 and the new Unicode Message Format Working Group (MFWG)
  - Individual introductions.
  - A brief history of each group.
  - Current efforts and plans for each group.
  - General discussion of message formatting.
  - Discussion of how we might work together to mutual benefit.

## Meeting summary:
- Attendees:
  - Corentin Jabot
  - Elango Cheran
  - JeanHeyd Meneide
  - Jens Maurer
  - Lyberta
  - Mark Zeren
  - Markus Scherer
  - Mihai Nita
  - Peter Brett
  - Romulo Cintra
  - Shane Carr
  - Steve Downey
  - Steven R. Loomis
  - Tom Honermann
- The meeting started off with a round of introductions.
- Tom provided a brief history of SG16 and changes championed for C++20.
  - Tom mentioned the work that went into `std::format` via
    [P1868](https://wg21.link/p1868)
    in order to produce correctly aligned text for monospaced presentation formats.
  - SLoomis stated that character display width is an important problem that is deserving of its own project.
  - PBrett asked if there were plans to enable `std::format` to handle text translation.
  - Tom stated that our current direction is captured in
    [P1238: SG16 Unicode Direction](https://wg21.link/p1238).
  - Markus provided some references for work being done in ICU to address C++20 incompatibilities:
    - https://github.com/unicode-org/icu/pull/979 (a pull request providing minimal changes to allow ICU to
      compile with C++20; basically a bunch of added `reinterpret_cast` casts for uses of `u8` string literals
      to continue using them as arrays of `const char`)
    - https://unicode-org.atlassian.net/browse/ICU-20984 (a proposal for a more principled change that avoids
      the need for many of the `reinterpret_cast` casts)
- Members of the MFWG provided an introduction and current status summary.
  - Romulo gave a general introduction:
    - The initial impetus for the group was the observed demand for client side message formatting and a lack
      of browser features needed to effectively enable it two years ago.
    - There are currently a number of libraries available that cumulatively account for millions of weekly
      downloads:
      - NPM trends:<br/>
        https://www.npmtrends.com/i18n-vs-i18next-vs-messageformat-vs-polyglot-vs-intl-messageformat-vs-fluent-vs-fbt-vs-format-message
      - Overview and analysis of various libraries:<br/>
        https://docs.google.com/presentation/d/1RujNFCq3gH9TUEKDB_uFdKWNG1A1j2_NBCdnTmnEqv0/edit#slide=id.g4af2a8f783_0_210
    - A recommendation was provided to join
      [ECMA TC39](https://tc39.es)
      and contribute to the group chaired by Shane Carr that is responsible for
      [ECMA-402](https://tc39.es/ecma402).
    - Discussed the idea of a new group with Shane focused on message formatting last year.
    - Shane brought lots of new people, got them talking, and worked with the Unicode consortium to create
      the new group.
  - Shane continued:
    - Message formatting was already recognized as an item to focus on for ECMAScript.
    - The problem isn't unique to ECMAScript; it is a big problem space.
    - A big question is, how much of the localization stack is to be covered?
    - The Unicode consortium formed the new group in January, 2020 as a Unicode subcommittee.
    - Romulo was named chair of the new group.
  - Mihai continued with an overview of the scope and design direction:
    - Think of message formatting like a locale aware implementation of `printf`.
    - But one that can handle plurals.
    - The idea is to separate the string from the localization data model.
    - For `printf`, the format is a sequence of parts, each of which contributes raw text or a placeholder
      with formatting data.
    - Proper internationalization requires a more complicated data model.
    - There are three major pieces needed:
      - The data model.
      - A serialization form.
      - A message store.
    - A goal is to provide a standard data model that can be mapped to various localization interchange
      formats; not to produce yet another message format.
  - Romulo wrapped up:
    - Have had 5 meetings so far.
    - Are still in the design and requirements discovery phase.
    - Are still working on design processes to ensure efficient operation.
- General discussion ensued:
  - PBrett asked about challenges faced where ICU is currently deficient.
  - Mihai responded that he has a document he can share:
    - A major challenge is that ICU has the only widely deployed formatting implementation.
    - There are some ECMAScript libraries.
    - ICU does not support inflections well.  For example, in English, one might say "the book", but in other
      languages, instead of inserting "the", the word "book" is changed.
    - ICU also doesn't handle combinations of plurals well.  For example, a statement like
      "I bought 5 books and 2 posters" requires a complext nested switch format due to combinatorial explosion
      and the syntax is clunky.
  - Markus provided an example of plural complexities.  Arabic has six different plural forms and more may be
    added to say "exactly one" or for "none".  Two instances of pluralization in a message can lead to dozens
    of possibilities.
  - Shane stated that the ICU message format is the defacto standard right now, but there is no specification
    for it.
  - Elango responded that there are different defacto standards across different language ecosystems.  Data
    literals in ECMAScript provide flexibility.  Many programmers roll their own solutions and this results in
    inconsistency.  The goal is to create a specification to encourage normalizing behavior across disparate
    implementations.
  - Jens commented on the complication of language bindings and extensive behavioral options.
  - Mihai agreed; message formatters congregate lots of functionality.
  - Mihai mentioned his prototype of a formatter that uses
    [Protocol Buffers](https://developers.google.com/protocol-buffers)
    to translate syntax between different formatters.  A comprehensive core data model is essential to be able
    to do so.
  - Elango stated that the general facility has just one output for message formatting; date formatting is
    provided by a plugin.
  - Mihai opined that it would be useful to have support for ranges as well.
  - PBrett stated that the ability to stream output is important for C++ and that this covers several
    orthogonal areas of concern:
    - The data model.
    - The abstract representation.
    - The concrete representation.
    - The sinks that messages go to.
    - Authoring of the translation database.
  - PBrett added that the above raises an important question for the MFWG to address: what are you trying to
    solve and what is the abstraction?
  - Jens observed that there appears to be little overlap between SG16 and the MFWG; when the MFWG specification
    is complete, SG16 will consume it.
  - Tom provided some of his perceptions of the benefits of working together.  First, we ensure that the output
    of the MFWG works for purposes that we envision.  Second, we get informed about infrastructure requirements
    that may require new facilities to meet in order to adopt the MFGW output.  For example, enhancements to
    locale support.
  - Jens noted that, for `std::format` to be able to provide message formatting, it would have to be able to
    access the message catalog.
  - PBrett observed that adding that complexty to `std::format` may be challenging; it may be difficult to
    separate dependencies.
  - Markus noted that the mechanism used to pluralize a message is distinct from the source of the
    pluralization data.
  - Tom asked for clarification; pluralization is more of an algorithm than a lookup?
  - Markus responded that the way ICU has worked for the last 25 years is to parcel out strings or states, and
    then combine them according to specific rules.
  - Jens stated that WG21 has shied away from localization isseus because the C++ story is so poor; serious work
    is needed here.
  - Mihai explained that, in the data model the MFWG is working on, a place holder is a cross reference to
    another string.  If the mapping is generic, then a generic binding can be used, but loading can be customized.
  - Jens expressed caution; we're wary of costs for features that are not used.  Paying such costs is fine when
    needed, but should not pose overhead when not being used.
  - Tom asked if the design can avoid such costs when such features aren't used.
  - Jens responded that that isn't a fair question for a data model.  A more appropriate question would be what
    the impact is to the tables used for pluralization data.
  - Mihai responded that pluralization is not a large data set.  The question is more relevant for inflection.
    Some languages are regular, but others are quite unregular and sorting requires a lot of data.
  - Mihai added that message formatting brings algorithms together, but the information needed to guide the
    formatter is distinct.
  - Jens asked if support for pluralization and inflections is in scope.
  - Elango responded that pluralization is, but that inflections may not be; this is work in progress.
  - Shane further responded that support for inflections is in scope as part of the effort to make a standard
    interface that enables plugging in extensions.
  - Shane added that the focus is to provide a solution that does not require an implementor to implement
    everything.  Implementors should be able to provide only the subset of features needed for a particular
    deployment.
  - Markus elaborated on ICU's pluralization support.  ICU doesn't attempt to determine the plural form for
    any word in any language.  Rather, it identifies ranges of numbers for 100+ languages where things must
    be done differently.  Translators are then required to author different messages.  Translation tools are
    designed to prompt translators for each translation form that is needed.  The pluralization form is then
    used for message selection.
  - Jens observed that the ICU design is exactly what causes the combinatorial explosion.
  - Mihai noted that the goal is to simplify the syntax, not to reduce the number of translations required.
  - PBrett asked how translators can provide translations conveniently in those cases.
  - Mihai responded that translation tools can do fuzzy matches and offer suggestions.
  - PBrett asked about the MFWG road map; is it a goal to produce a Unicode TS?
  - SLoomis responded, yes.
  - PBrett asked if there is a tentative time line.
  - Romulo responded that they are still in the design phase, so there is no clear road map right now.
  - Mihai added that they have been focused on collecting use cases and feature requests; the rate of additions
    is decreasing.
  - Mihai elaborated that getting consensus on a data model being a goal took some time.
  - Corentin stated that it would be great to support a common syntax in C++ and ECMAScript so that translators
    have consistent experiences.  For `std::format`, Python's syntax was adopted thereby enabling developers to
    switch easily.
  - Mihai responded that a common format is anticipated for translators, but that does not necessarily correspond
    to what a programmer writes.
  - PBrett hypothesized that a C++ implementation could have a `constexpr` solution that uses C++, but that can be
    translated to some other syntax.
  - PBrett added that we need to think of how to deprecate and replace `std::message`.
  - Jens noted that understanding the data model is important to envision how the various parts fit together and
    asked if a draft data model exists.
  - Mihai responded that there are currently two documents on the data model.  Elango provided a document that
    argues for a data model, and Mihai provided one that maps a model to one of several implementations and
    discusses how it can be modified to add features.  There is no final draft.
    - Elango's doc:<br/>
      https://docs.google.com/presentation/d/1fBfawWNfniCFox-PltCMyVtbcVwYGYkk78GUbWzas5o/edit#slide=id.g8254abe56c_0_0
    - Mihai's doc:<br/>
      https://docs.google.com/presentation/d/1dyW29SlqjPRZVScobqEXjnP29fhbqMkCfgxPOWj3Tnw <br/>
      (currently requires permission to access)
  - Corentin asked if there is a reference syntax available and noted that none of us our linguistics experts.
  - Mihai responded that a syntax for ECMAScript is anticipated along with a language independent form in
    a structured data format like JSON.
  - Markus suggested that SG16 should consider whether it wants to do something in this area or whether this
    functionality should be left to non-standard libraries.
  - Tom responded that the design direction would allow for a standard implementation, but doesn't restrict the
    use of non-standard implementations.
  - Jens suggested that it would be good to appoint someone from SG16 to be a liazon to attend MFWG meetings and
    keep tabs on things.
  - Shane agreed with that approach; it would help to maximize utility to consumers.
  - Jens commented that what the committee needs is a standard that we can defer to that was produced by
    experts since, if left to our own devices, we'd probably produce a poor design.  Dependence on such a standard
    needs to be figured into our road map.
  - PBrett asked about the
    [MFWG mailing list](https://groups.google.com/a/chromium.org/forum/#!forum/message-format-wg)
    and
    [MFWG github site](https://github.com/unicode-org/message-format-wg);
    neither looks particularly active.
  - SLoomis replied that most activity is happening in github issues.
  - Shane added that there is a
    [Slack Unicode channel](https://unicode-org.slack.com).
  - PBrett suggested that SG16 should discuss more, reflect, and contemplate how we want to move forward.
  - PBrett asked what SG16 can do to help facilitate work by the MFWG.
  - Mihai responded; try not to invent something new.
  - Corentin noted that we need to re-design our locale facilities before we can take on message localization
    and that we need to implement facilities matching those in
    [ECMA-402](https://www.ecma-international.org/publications/standards/Ecma-402.htm).
  - Tom returned to the subject of requirements and asked if there are cases where multiple locales need to be
    consulted for the same message.
  - Markus responded that mixtures of locales appear in cases where a placeholder refers to, for example, a name.
  - Steve stated that such scenarios are common with currency; it is common, for example, to use USD outside of
    US locales.
  - Mihai added that this also happens with dates.  Dates may be presented in multiple formats.
  - Steve added that use of a locale independent date format might be consistently used regardless of locale.
  - Mihai stated that these scenarios should be possible to address, but not optimized for.
  - Tom asked if the notion of locale independent message formatting is relevant to the MFWG.
  - Markus replied that there are good use cases for locale independent formatting; logging for example.
  - Steve added that JSON output should not be localized.


# February 26th, 2020

## Draft agenda:
- Post-Prague follow up.

## Meeting summary:
- Attendees:
  - Corentin Jabot
  - David Wendt
  - JeanHeyd Meneide
  - Jens Maurer
  - Peter Bindels
  - Peter Brett
  - Steve Downey
  - Tom Honermann
  - Zach Laine
- [P2071R0: Named universal character escapes](https://wg21.link/p2071r0):
  - Tom provided a status update.  Waiting on a response to add an additional co-author.  Working on
    updates to address EWG feedback.  Wording will need to be re-done for P2029.  On track for review
    by EWG again in Varna; will hopefully be made tentatively ready then.
- [P2029R0: Proposed resolution for core issues 411, 1656, and 2333; numeric and universal character
  escapes in character and string literals](https://wg21.link/p2029r0):
  - Tom stated an update will be submitted for the Prague post-meeting mailing with the intent that it
    be discussed at the next core issues processing meeting.
  - Jens stated that the next core issues processing meetings are planned for March 23rd and April 20th.
- Renaming universal-character-name:
  - Corentin brought up an
    [email](https://lists.isocpp.org/sg16/2020/02/1152.php)
    that he had sent to the SG16 and core mailing lists regarding a desire to rename
    *universal-character-name* to *universal-character-codepoint* since no names are actually used in these
    productions (code point values are).
  - Jens stated that it can be difficult to get consensus on a change via the core reflector; such a change
    needs core buy in.
  - Corentin asked how he should proceed.
  - Jens replied that the issue could be discussed in the next core issues processing meeting.  The process
    to get an item on the agenda for those meetings is to get it on the CWG wiki page for Varna, but the
    Varna wiki hasn't been populated yet.  Jens said that he would poke at someone to get the wiki
    structure in place.
  - Tom asked for more details about this process and whether it is really ok to get changes like this
    initiated without a paper or core issue.
  - Jens replied that a paper is best to ensure proper attention and progress.
  - Jens added that an updated core issues list hasn't been published for some time now.
  - \[ Editor's note: The last published core issues list is revision 100 and has a date of 2018-04-11. \]
  - Jens asked if *universal-character-codepoint* is what we want and suggested *unicode-code-point* as an
    alternative.
  - Tom expressed support for Jen's suggested alternative.
  - Zach expressed a preference for something more specific since this production is for one particular way
    to express a code point.
  - Jens responded that this is a grammar term and asked if the grammar term for P2071 should also be named
    *something-codepoint* because it designates one.
  - Corentin expressed support for that sentiment.
  - Zach asked if the implication is that both `\uNNNN` and `\N{...}` would fall under *unicode-code-point*.
  - Jens replied that they are distinct because `\uNNNN` can be generated from characters not in the basic
    source character set that appear in identifiers in the source code.  `\N{...}` likely gets effectively
    quickly translated to `\uNNNN`.
  - Jens opined that the name isn't super important since this is just a grammar term and people should
    expect to have to look up exactly what it means.
  - Zach stated that *unicode-code-point* seems like the right choice then.
  - Tom asked about using the names *unicode-code-point* for `\uNNNN` and *unicode-code-point-name* for
    `\N{...}`.
  - Corentin suggested that, in P2071, *named-escape-sequence* be renamed to *unicode-named-escape-sequence*
    for the `\N{...}` case.
  - Jens asked if `\N{...}` is allowed in identifiers.
  - Tom replied that it is not.
  - Jens noted that being a significant difference from `\uNNNN`.
  - Tom expressed some hesitation with regard to adding "unicode" to *named-escape-sequence* since, in theory,
    we could support non-Unicode names like D does.
  - \[ Editor's note: D uses HTML 5 entity names for its named character escapes. \]
  - Jens expressed a preference for *named-escape-sequence* as it is simple and matches nearby grammar terms
    like *octal-escape-sequence* and *hexadecimal-escape-sequence*.
  - PBindels asked about just using *code-point* for `\uNNNN`.
  - Corentin stated that Unicode is needed in this case.
  - Jens agreed noting that the syntax is specific to Unicode code points.
  - Jens asked to confirm that there is no requirement for an implementation to have a list of acceptable or
    unacceptable code points for `\uNNNN` other than for surrogate code points and the range of code point
    values (0-0x1FFFF).
  - Tom confirmed; implementations are not required or allowed to map an unrecognized code point to a
    replacement code point.
  - Jens acknowledged and added that programs that specify an unassigned code point will not be rejected either.
  - Jens asked if naming this *unicode-code-point* implies a valid character.
  - Steve suggested that, perhaps, the right name is *unicode-scalar-value*.
  - Everyone expressed profound distate for the scalar value term.
  - Jens suggested that P2071 be updated to add editorial direction to rename *universal-character-name* to
    *unicode-code-point*.
  - Tom agreed to do so.
  - \[ Editor's note: concurrent with this meeting, a prominent core member replied to Corentin's email and
    requested that we retain the *unversal-character-name* name since it has been in use in C99 and C++23 for
    20 years now and is referenced in existing literature.  Due to there being opposition to the name change,
    Tom then decided not to pursue the editorial rename via P2071.  Anyone wishing to pursue the rename
    should therefore write a separate paper. \]
- [P0592R4: To boldly suggest an overall plan for C++23](https://wg21.link/p0592r4):
  - Tom introduced the topic.  At plenary in Prague, Peter Bindels asked what the process would be to amend
    P0592.  Tom was approached by several committee members arguing that Unicode support should be added as
    a priority for C++23.  Tom is concerned about spending committee time addressing a problem that might not
    exist and is worried that attempting to add our favorite topic to the priority list might inspire other
    groups to argue for adding theirs potentially consuming significant amounts of committee time.
  - Jens asked what papers aren't making progress.
  - Tom replied that, right now, SG16 is the bottleneck for SG16 work.  The EWG and LEWG chairs have been
    quite supportive of making progress on Unicode matters.
  - PBindels stated that he raised this in plenary partially to encourage people to write papers; we want to
    ensure that EWG and LEWG are prepared for additional work that builds on the ground work we've been laying.
  - Steve suggested a potential bad scenario.  Two years from now, there could be a glut of pattern matching
    papers consuming lots of committee time just as C++23 is wrapping up.
  - Tom agreed that is a possible concern, but added that he doesn't think we can preempt it.
  - PBindels stated that P0592 is meant as a general guideline and that we need a plan for ourselves so that
    we know what we are aiming for in C++23.
  - PBrett agreed and added that knowing what we want, when we want it by, and who is responsible would be
    helpful.
  - Tom responded that the SG16 github site has issues tracking the SG16 work currently in motion as well as other
    tentative ideas.  Many of those issues are marked as "help wanted" and are available for volunteers to take
    on.
  - Tom added that [P1238](https://wg21.link/p1238) is due for an update.  That paper could be updated to list
    items that we want help with.  Perhaps we need to do more outreach to enlist additional help.  We could post
    help wanted tweets or ask more people to get involved when giving talks.
- [P1949R1: C++ Identifier Syntax using Unicode Standard Annex 31](https://wg21.link/p1949r1):
  - Tom summarized the current status; Steve has been preparing a revision following EWG review in Prague.
  - Steve stated that the paper is ready for the post-meeting mailing.
  - Tom stated that we lost the tentatively ready status in EWG for this paper following
    [additional email discussion](https://lists.isocpp.org/sg16/2020/02/1122.php)
    that raised concerns about possible undefined behavior in conjunction with token pasting.
  - Tom asked if the paper needs to address token syntax as well as identifier syntax.
  - Corentin replied that NFC checking should happen after preprocessing.
  - Tom asked if the grammar for identifiers is relevant for tokens.
  - Jens replied that *preprocessing-token* is distinct and that they get converted into identifiers, keywords,
    etc... at a particular translation phase.
  - Jens added that this occurs in translation phase 7 per
    [[lex.phases]p1.7](http://eel.is/c++draft/lex.phases#1.7) and
    [[lex.token]p1](http://eel.is/c++draft/lex.token#1).
    Core language wording should be added here to state that an identifier shall be in NFC form.
  - \[ Editor's note: In the draft wording, this is added to
    [[lex.name]](http://eel.is/c++draft/lex.name). \]
  - Steve asked if this is a "shall" or "must" situation.
  - Jens replied that "shall" is correct because a diagnostic is required and that "must" is a forbidden term
    in normative wording.
  - Tom mentioned that Peter Bindels has drafted a paper arguing for P1949 to be designated as a DR for C++20.
  - Jens stated that the DR process would be to get P1949 adopted for C++23, and then get a plenary straw poll
    to apply it as a DR against C++20.
  - Steve agreed to add content to the paper arguing for treating the matter as a DR.
  - PBindels told Steve to take whatever content he wanted from his DR draft and that he will abandon it.
    - [Peter's draft](https://github.com/dascandy/fiets/blob/master/papers/DxxxxR0_P1949_as_DR.fiets)
  - Jens suggested putting content directly in both the paper's front matter and at the beginning of the
    core wording that this be considered a DR.
  - Jens added that to ensure this is highlighted in core discussion.
  - Tom asked if there would then be two core motions.  One to accept the paper for C++23 and another to
    accept it as a DR for C++20.
  - Jens replied that it could be one motion: "adopt for C++23 and consider as a DR for C++20"
- [P1844R1: Enhancement of regex](https://wg21.link/p1844r1):
  - Tom summarized the Prague outcome.  We declined to forward this paper on and Peter Bindels has authored a
    draft paper to deprecate `std::regex`.
  - Tom aplogized for not yet reviewing Peter's deprecation paper.
  - PBindels stated he is waiting for review feedback from a select group of reviewers before sharing the draft
    more widely.
  - PBindels summarized the paper; it includes rationale for why programmers shouldn't use `std::regex`,
    performance numbers, ABI issues, votes in Prague, etc...
  - PBindels added that he would like to add more details on why the Visual C++ implementation is presumably
    so heavily impacted by ABI concerns.
  - Tom replied that the Visual C++ implementation exposes the entire state machine in template instantiations,
    so no changes can be made that affect the state machine.
  - Corentin suggested additional content stating that the design is overly complicated because it supports
    so many regex languages and that the requirement to do so impacts performance.
- [P1885R1: Naming Text Encodings to Demystify Them](https://wg21.link/p1885r1):
  - Tom suggested adding a list of encodings that are supported by ICU, iconv, Windows, etc..., but that are
    not present in the IANA database.
  - Corentin replied that he would try to do so.
  - Tom suggested that we try to register an encoding to see how burdensome doing so is to assuage fears about
    support for unrepresented encodings.
  - Corentin replied that he didn't think that would be a good use of our time.
  - PBrett added that doing so would be an abuse of process; the IANA registration process should only be used
    to register encodings for which there is a demonstrable need.
  - Tom acknowledged and agreed.
  - Tom suggested adding additional use cases to the paper to make it more evident to LEWG(I) how this functionality
    is expected to be used.
  - Tom added that such use cases should include intended future direction as well; e.g., interaction with
    [P1629: Standard Text Encoding](https://wg21.link/p1629).
  - Corentin agreed to do so.
  - JeanHeyd stated that he would look into prototyping integration between P1885 and P1629 and making it available
    on godbolt.
- [P1953R0: Unicode Identifiers And Reflection](https://wg21.link/p1953r0):
  - Tom expressed uncertainty as to what the next steps are.
  - Corentin stated that we need to get P1949 accepted first.  We can then revisit reflection and provide our
    recommendations to SG7.
  - Corentin added that we do need to keep on top of what SG7 is targeting for C++23.
- [P1040R5: std::embed](https://wg21.link/p1040r5):
  - Tom summarized the Prague outcome.  EWG expressed support for a file/directory handle `#depend` based
    solution.  That solves SG16 concerns; unless there is still a need to support paths that are relative to a
    handle at translation phase 7.
  - JeanHeyd stated that there are lots of issues with the VFS/node/handle approach.  But regardless, the SG16
    recommendation to use `char8_t` and UTF-8 resolves any SG16 related concerns.
- Tom stated that the next meeting will be March 11th and that we'll be meeting with the new Unicode Message
  Format Working Group.


# February 5th, 2020

## Draft agenda:
- Preparations for Prague.
- P2020R0: Locales, Encodings and Unicode
  - https://wg21.link/p2020r0
  - General discussion, corrections, suggestions, etc...
- P1629R0: Standard Text Encoding
  - https://wg21.link/p1629r0
  - Status update from JeanHeyd.

## Meeting summary:
- Attendees:
  - Corentin Jabot
  - JeanHeyd Meneide
  - Jens Maurer
  - Lyberta
  - Peter Bindels
  - Peter Brett
  - Steve Downey
  - Tom Honermann
- Preparations for Prague.
  - PeterBr asked if it would be possible to attend the SG16 meeting in Prague remotely.
  - Jens provided some background:
    - Historically, remote attendance has not been allowed for a variety of reasons including but not limited to:
      - voting concerns
      - confidientiality concerns
      - attendance by people not familiar with our processes
    - SG and WG chairs have facilitated remote attendance on occasion for paper authors or well known experts.
    - For Prague, the Corona virus outbreak has prompted an exception for this meeting for paper authors.
    - SG chairs can choose to facilitate remote attendance subject to technology support.
  - PeterBr stated that the UK national body is considering making a request to enable remote access for people
    facing attendance challenges due to issues like VISA access and child care responsibilities.
  - Tom indicated that a member of the UK national body had reached out to him to ask how SG16 conducts our telecons.
  - Jens stated that the number of meeting attendees is raising logistial and hosting challenges.
  - Jens added that hotel wifi may not suffice for video conferencing.
  - Tom asked if Jens could provide audio gear that SG16 could use to facilitate remote attendance.
  - Jens confirmed he could.
  - Tom confirmed that a best effort approach will be made to facilitate remote attendance via BlueJeans.
  - Tom asked everyone to review the tentative schedule
    - http://wiki.edg.com/bin/view/Wg21prague/SG16
  - Jens suggested removing the Wednesday afternoon time slots since we don't have a room reserved for that time.
  - Tom agreed to do so.  \[Editor's note: and did so.\]
- Tom announced that the newly formed Message Formatting Unicode Working Group has been invited to attend the SG16
  meeting planned for March 11th.
  - https://github.com/unicode-org/message-format-wg
- P2020R0: Locales, Encodings and Unicode
  - https://wg21.link/p2020r0
  - Corentin introduces:
    - The paper chould be updated to include additional motivation for support of localization in the standard
      library.  However, since locale support is already present in the standard library, there is a desire not
      to distract from other topics and attempt to motivate unnecessarily.
    - The intent of the paper is to provide guidance and establish direction.
    - The existing locale support in the standard library is deficient, but in use regardless.  We could seek to
      deprecate it in favor of new facilities, though actually marking these interfaces `[[deprecated]]` could
      be problematic for some projects due to compiler warnings.
    - A primary point in this paper is that character encodings and locales are distinct concerns, though they
      have been historically conflated, particularly in POSIX.
    - High quality locale support depends on Unicode algorithms.
    - Attempting to provide locale support for non-UTF encodings is not realistic.
    - Whether a character is an uppercase or lowercase letter is not locale dependent.  However, case conversion
      is locale dependent.
    - The existing character classification functions are deficient since they operate on code units as opposed
      to sequences of code units or code points.
    - New locale facilities must be Unicode based.  For support of legacy encodings, conversion to Unicode and
      back will suffice.
    - Iostreams and locale are closely tied and operate on individual code units.  Proper localization cannot
      be provided using code unit based operations.
    - Linux and macOS deployments nearly exclusively use a UTF-8 locale.  At program startup, the program
      locale is set to "C".  Setting it to "C" is desirable; programs should opt-in to localization behavior.
      However, setting it to "C" also has the effect of changing the encoding and that is not desirable.
  - PeterBr stated that support for multiple encodings is not required for locale support.
  - Corentin agreed with a caveat; that is true for Unicode encodings, but when not using Unicode encodings,
    switching locales requires switching encodings.
  - Steve stated that, for one of their internal facilities, encoding is important for understanding what is
    provided by the locale library since the library provides `char` based interfaces and the localization data
    is encoding dependent.  It would be possible to retranslate all existing messages, but would be a large
    undertaking and getting localization wrong is expensive.  We need to enable bridges to the past.
  - PeterBr noted that we can't expect UTF-8 locale support on Windows; it will be UTF-16.
  - Corentin responded stating that is ok so long as it is Unicode since conversion to UTF-8 doesn't lose data.
  - Steve remarked that it is impressive how much locale related code works by accident.
  - Corentin supplied a list of operations affected by locale: case mapping, collation, search.  Search was
    surprising; it depends on locale because matching base characters is desired for some locales, but not for
    others.  The break algorithms are also locale dependent.
  - Corentin added that, thanks to Han unification, text rendering is locale dependent.
  - Jens observed that section 4 omits some items; number formatting for example.
  - PeterBr stated it would be helpful to have some Japanese contributors in SG16 to answer questions about
    formatting in their locales.
  - Corentin opined that it is best to just follow Unicode; it specifies how to handle locales.
  - Corentin added that, in some locales, multiple numeric formats may be used.  For example, in India.
  - PeterBr asked if the character classification functions could we deprecated if replacements were made
    available.
  - Corentin replied that they tend to be used in cases where programmers explicitly expect ASCII.
  - Jens stated that we all likely agree that the current character classification functions are defficient
    and that new facilities are required in order to deprecate them.
  - PeterBr asked how likely implementors are to be willing to ship a Unicode DB.
  - Corentin suggested that discussion of that be postponed to discussion of
    [P1628 -  Unicode character properties](https://wg21.link/p1628r0).
  - Jens objected to the idea of defaulting the program's startup encoding to UTF-8 if the environment
    specifies a UTF-8 encoding.  The "C" locale only supports the basic execution character set, e.g., ASCII.
    Programs that want to support extended characters should call `setlocale(..., "")` at program startup to
    opt-in.
  - Corentin stated that the choice C made to default the locale to "C" was a good choice for formatting
    facilities; many programs aren't intended to produce locale dependent formatting.  But encoding is different.
  - Steve stated that the as-if rule is leaned on here as implementations don't actually call
    `setlocale(..., "C")` during startup; adding a call to `setlocale(..., "")` would be a major change.
  - Tom clarified that Corentin's intent is only to adopt the encoding from the environment locale on program
    startup, not the locale formatting settings.  The proposal states that if, for example, the locale specified
    an encoding of UTF-8, then the as-if call on program startup would be something like
    `setlocale(LC_ALL, "C.UTF-8")`.
  - Corentin acknowledged that the way C and C++ are tied is a valid concern and that implementors depend on the
    underlying OS for locale support.
  - Jens expressed skepticism regarding the ability to change the program startup behavior, suggested that a
    new interface to retrieve the environment specified encoding be provided, and that `setlocale` be left alone.
  - Tom agreed that new functionality doesn't have to follow current behaviors.
  - Jens continued; new functionality can be provided that is independent of `setlocale`.
  - Jens opined that "C.UTF-8" doesn't make sense.
  - Tom stated that Python made a change to assume UTF-8 for the "C" locale and that the Python
    [PEP-538: Coercing the legacy C locale to a UTF-8 based locale](https://www.python.org/dev/peps/pep-0538) and
    [PEP-540: Add a new UTF-8 Mode](https://www.python.org/dev/peps/pep-0540)
    documents are informative for motivation.
  - PeterBr asked if use of the "C" locale implies use of the encoding of the execution character set.
  - Jens replied that, effectively, yes, but wording could make that more clear.
  - Tom stated his goal for this paper in Prague; to poll a subset of the possible future directions listed in
    section 6 to establish priorities for them; we can then identify tasks and papers to write.
  - Jens expressed a desire for a road map for the future before moving forward with deprecation.
  - PeterBr agreed and stated that a desire for a road map underscored the need for good motivation.
  - Corentin stated that we need to identify all of the current implicit and explicit locale dependencies.
  - PeterBr suggested incremental improvements may be made by adding overloads with explicit locale parameters.
  - Tom suggested that we spend an evening in Prague going through the paper in more detail with the intent to
    improve presentation and fill in gaps.
- P1629R0: Standard Text Encoding
  - https://wg21.link/p1629r0
  - JeanHeyd introduced:
    - [N2440](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2440.pdf) and
      [P1629](https://wg21.link/p1629) are intended to provide text decoding, encoding, and transcoding interfaces.
    - These replace `wstring_convert` and friends.
    - UTF-8 is difficult to enforce in `char` because non-UTF-8 data arrives in `char` based strings.
    - C provides few useful interfaces in this area.
    - WG14 approved parts of N2440 and an implementation is available in a standalone library.
    - Plans to submit implementations of N2440 to glibc and musl libc are pending.
    - P1629 provides extensible encoding objects.
    - There is an implementation of P1629 that provides encoding, decoding, transcoding, validation, and code point
      counting services.
  - Corentin asked what the motivation is for contributing new interfaces to C.
  - JeanHeyd responded that it makes sense to do so and that WG14 has already approved direction to add the mbs to
    UTF conversion variants.
  - Tom expressed his motivation for contributing to C; doing so reduces friction between the languages.
  - PeterBr asked if the implementation of N2440 uses SIMD instructions.
  - JeanHeyd replied that it does not yet, partially because the musl maintainers will want straight C implementations.
  - Jens asked why the single-character interfaces are not proposed.
  - JeanHeyd replied that only the restartable variants are being proposed.
  - Jens stated that WG14 will consider a WG21 approved proposal to qualify as implementation experience.
  - PeterBr asked about `replacement_code_unit` and how a replacement character that requires multiple code units
    would be specified; it seems like the replacement character should be provided as a string.
  - Tom expressed confusion about the existence of `replacement_code_unit` as he expected a replacement code point
    to be specified.
  - \[Editor's note: Tom later started an email thread on the SG16 mailing list regarding this:
    https://lists.isocpp.org/sg16/2020/02/1101.php. \]
  - JeanHeyd replied that a replacement code point is preferred and that the replacement code unit is a fall back.
  - Corentin stated that he didn't think `replacement_code_unit` is needed at all.
  - JeanHeyd replied that it is used to distinguish between errors happening in different encode/decode directions.
  - Steve suggested that, perhaps, better names are needed to communicate their intent.
  - JeanHeyd replied that he will update the replacement names and make them ranges or strings.
  - Jens observed that the design appears to be all compile-time based and asked how run-time dependent encoding
    is handled.
  - JeanHeyd replied that the compile-time implementation can be wrapped in a run-time design.
  - Jens expressed a desire to see the design specified in terms of concepts.
  - JeanHeyd replied that the proposal will use concepts, but that the current implementation is intended to work
    with pre-C++20 compilers.
  - Tom asked how much of the proposal is implemented.
  - JeanHeyd replied that interfaces have been implemented for decoding, encoding, transcoding, validation, and
    code point counting.
  - JeanHeyd added that support for normalization hasn't been completed, but normalization can be done later.
- Tom stated that the next meeting will be February 26th and the focus will be on post-Prague follow up.

  
# January 22nd, 2020

## Draft agenda:
- P1885R0: Naming Text Encodings to Demystify Them
  - https://wg21.link/p1885
  - Follow up on recent mailing list discussions.
  - Identify and discuss intended use cases.
- P2020R0: Locales, Encodings and Unicode
  - https://isocpp.org/files/papers/P2020R0.pdf
  - General discussion, corrections, suggestions, etc...

## Meeting summary:
- Attendees:
  - Corentin Jabot
  - David Wendt
  - Hubert Tong
  - Jens Maurer
  - Peter Bindels
  - Steve Downey
  - Tom Honermann
  - Zach Laine
- P1885R1: Naming Text Encodings to Demystify Them
  - https://wg21.link/p1885r1
  - Tom introduced the topic for discussion:
    - SG16 approved P1885R0 to forward to LEWG in Belfast.
      - http://wiki.edg.com/bin/view/Wg21belfast/SG16P1885R0
    - Corentin has now provided an R1 with minor updates.
    - Since then, concerns were raised on the SG16 mailing list:
      - https://lists.isocpp.org/sg16/2019/12/0993.php
      - (See email thread continuation in January as well)
    - Questions of use cases have been raised.
  - Corentin stated that use cases haven't changed from his perspective and that the discussion on the
    mailing list went off on a tangent.
  - Tom replied that the discussion suggested a lack of consensus on the importance of a name vs a MIB ID.
  - Corentin stated that what is proposed is just a name intended to resolve issues with names not being
    portable across platforms.  The proposal relies on MIB IDs to correlate names for use with third party
    products.  The proposal does not allow dynamically adding names so as to avoid the possibility of
    inconsistent results.
  - Tom asked what the motivation was for not including enumerators for all MIB IDs in `text_encoding::id`,
    but to require the implementation to support all names and aliases from the
    [IANA Character Set Registry](https://lists.isocpp.org/sg16/2019/12/0993.php).
  - Corentin replied that the requirements were changed in R1.  Hosted implementations are now required to
    support all of the names, but freestanding implementations need not.
  - Tom asked for clarification regarding omission of enumerator IDs.
  - Corentin replied that, if we specify enumerator names for all registered character sets, then we'll
    have to maintain that list.  Additionally, if implementors can add names, that could lead to portability
    or compatibility issues.  Discussion with others prior to Belfast suggested more names were not needed.
  - Jens summarized the concern; the RFC has ~150 names and we would have to put all 150 names into the
    enumeration and deal with the maintenance.  If we select just a few names, then we don't have a
    maintenance burden.
  - Tom countered that use of the `cs` prefixed identifiers described in section 2.3 of
    [RFC 2978](https://tools.ietf.org/html/rfc2978) and maintained in the
    [IANA Character Set Registry](https://lists.isocpp.org/sg16/2019/12/0993.php)
    would avoid the portability and compatibility concerns and provide a specification we can defer to.
  - Corentin replied that it isn't quite that simple because of version skew and that exposing MIB IDs to
    programmers has limited value to begin with.
  - Tom countered that, in the example use case provided in Belfast, you don't necessarily know what the
    name is.
  - \[Editor's note: That example use case is:
    ```
    template<class traits, class Rep, class Period>
    void print_fancy_suffix(basic_ostream<char, traits>& os, const duration<Rep, Period>& d)
    {
      if constexpr (text_encoding::literal().mib == UTF-8) {
        os << d.count() << "\u00B5s";
      } else {
        os << d.count() << "us";
      }
    }
    ```
    \]
  - Corentin replied that the use case could still be covered by comparing the implementation provided
    `text_encoding` object with one constructed by the programmer with a name.
  - \[Editor's note: Presumably something like:
    ```
    template<class traits, class Rep, class Period>
    void print_fancy_suffix(basic_ostream<char, traits>& os, const duration<Rep, Period>& d)
    {
      if constexpr (text_encoding::literal() == text_encoding("UTF-8")) {
        os << d.count() << "\u00B5s";
      } else {
        os << d.count() << "us";
      }
    }
    ```
    \]
  - Tom opined that string names are good for interaction with current third party libraries, but IDs are
    preferred for the example provided
  - Corentin replied that adding more enumerators is ok, but expressed discomfort with deferring to the
    IANA registry due to the possibility of incompatibilities arising from version skew.
  - Steve noted that the proposal only intends to provide portable names; there is no requirement for
    encoders and decoders to be provided.
  - Zach observed that no enumerator is provided for Windows-1252 and asked how an implementor that
    frequently traffics in that encoding would provide support.
  - Corentin responded that a `text_encoding` object can be constructed by name or that the fixed numeric
    value from the IANA registry can be used.
  - JeanHeyd asked if we could reserve a range of MIB IDs for use by implementations similar to the Private
    Use Area in Unicode.
  - Corentin replied that he is strongly opposed to doing so.
  - Corentin asked if we really want all of these names to be available as identifiers when we can just
    use strings.
  - Zach responded that he thinks it makes sense for cases where we know compilers default to certain encodings.
  - Corentin repeated that he doesn't want implementors to add their own names.
  - Jens asked about the source for the names whether as strings or identifiers.
    [RFC 3808](https://tools.ietf.org/html/rfc3808) lists the MIB names with interesting spellings, and
    [RFC 2978](https://tools.ietf.org/html/rfc2978) defines a registration process, but neither provides
    the latest names.
  - Steve provided the URL to the IANA registry and explained that the RFCs don't change, but specify the
    URL for the registry; which doesn't change often.
    - https://www.iana.org/assignments/character-sets/character-sets.xhtml
  - Tom added that the IANA registry mostly changes for administrative reasons, not because of new character
    set registrations.
  - Jens asked how it is determined which names are good for enumerators.
  - Tom replied that
    [RFC 2978](https://tools.ietf.org/html/rfc2978) specifies that each registered character set have an
    associated name prefixed with "cs" that is appropriate for use as an identifier.
  - Jens asked why the names in the proposal do not match the "cs" names.
  - Corentin responded that he picked names that he preferred.
  - Jens asserted that, in that case, implementors cannot extend the list.
  - Zach stated that there isn't much cost in taking the list of "cs" prefixed names, removing dashes, and
    dumping that list in the wording and asked again for motivation for omitting them.
  - Corentin replied that he thought they were not needed.
  - Zach agreed that many would not be used much, but determining which ones are important would be difficult
    where as just including them all would be easy.
  - Tom asked Corentin, why he felt comfortable deferring to the IANA registry for string names, but not for
    enumerator names?
  - Corentin replied that he felt that the names and alias names were definitive, but that the enumerator
    names seemed more fuzzy.
  - Corentin asked Jens if there are concerns regarding the use of trademark names in the standard; many of
    the character set names include trademark names.
  - Jens replied that we already use trademarked names like Windows and POSIX in the filesystem specification.
  - Steve added that these names have already been vetted by their respective owners, if necessary, for
    inclusion in the registry.
  - Jens asked if the names in the IANA registry might already be reflected in an ISO standard that we could
    reference instead.
  - Corentin replied that he was unaware of such an ISO standard.
  - Tom asked Jens how a search for such an ISO standard could be conducted.
  - Jens suggested searching for "character set" in the ISO list.
  - Steve noted that the RFC describing the IANA registration process does mention ISO standards such as
    ISO 10646, ISO 8859, and ISO 2022.
  - Corentin stated that web browsers, iconv, ICU, etc... all use the IANA registry; it is the defacto standard.
  - Jens expressed some uncertainty with regard to how to refer to these RFCs from the standard, but mentioned
    that we did similarly for the time zone database which is even less regulated.
  - Jens raised a concern about impact to small/embedded implementations.  As proposed, they would have to
    include an instance of the string name table with every instance of the program and that could be problematic
    even for some hosted implementations.
  - Tom suggested that, if the string table is not referenced; e.g., if none of the `text_encoding` factory
    functions is referenced or if the `<text_encoding>` header is not included, that the implementation might
    be able to omit it.
  - Jens suggested that it would be helpful if the paper addressed cost of implementation and anticipated
    impact to deployments.
  - JeanHeyd suggested that the guarantee we make should be that if only `text_encoding::system()` or
    `text_encoding::literal()` are called, then there should be no string table overhead.
  - Jens asked if an implementation could provide support for a reduced set of names.  If not, the discussion of
    how to reduce deployment cost is warranted since, as proposed, this is not a zero-cost of zero-overhead
    solution.
  - Jens also stated a preference for the `system()` and `wide_system()` functions to return a MIB ID rather
    than a `text_encoding` object.
  - Corentin responded that there may be cases where the system encoding is not registered with IANA.  In that
    case, the MIB ID would be "unknown"; and a different interface would have to be used to retrieve the string
    name of the encoding anyway.
  - JeanHeyd provided WTF-8 and Modified UTF-8 as examples of encodings that are not registered with IANA but
    that are known to be in use on Android and elsewhere on the web.
  - Jens suggested that, in such cases, the implementation register their encoding.
  - Zach asked to clarify what the motivation is for supporting string names at all.
  - Tom responded that third party products like iconv and ICU have interfaces that require use of string names.
  - Corentin confirmed.
  - Tom added that the IANA registry is effectively a common subset of recognized names.
  - Zach stated a preference for omitting string names and just relying on MIB IDs.
  - Corentin responded that doing so would complicate use of iconv.
  - Hubert expressed a lack of motivation for an interface that relies on numeric values that no one knows;
    the string names make sense.
  - Jens pondered if string name to MIB ID lookup was an orthogonal feature.
  - Tom stated that question was posed in the mailing list discussion as well.
  - Corentin mentioned existing host system interfaces.  Windows provides a code page with an ID.  POSIX systems
    provide a name and no ID.
  - Jens suggested that an interface that provides a string name does not suit all use cases.  For example,
    a programmer might desire to assert a specific system encoding; that shouldn't require a full string table.
  - Zach expressed a desire for the interface to provide more safety and that he would prefer a list of
    identifiers over a list of string names.
  - Hubert suggested other benefits of the string names, 1) useful for interaction with the system and third party
    libraries, and 2) useful for interchange or serialization.
  - Hubert expressed concern about use of a string interface for looking up an encoding name and asked what name
    is provided in response to a lookup of a MIB ID.
  - Corentin replied that there is no proposed lookup interface that accepts a MIB ID.  The factory interfaces
    like `text_encoding::system()` return a preferred name, but otherwise, the name provided when constructing
    a `text_encoding` object is preserved.
  - Jens expressed a desire for a low-level interface that just returns an integer that could be used to assert
    the environment is UTF-8 without having to compare with a bunch of strings; that could be a zero overhead
    facility.
  - Hubert asked if there is overhead if neither of `text_encoding::system()` or `text_encoding::wide_system()`
    is called.
  - Corentin responded that yes, there is, but it is low.
  - Hubert cautioned that some standard library implementors are likely to oppose anything that increases
    startup cost or requires "static constructors".
  - Tom asked why the interface couldn't perform a lazy lookup.
  - Corentin responded that calls to `setlocale()` could interfere; `text_encoding::system()` is intended to
    return the locale dependent encoding known at program startup time.
  - \[Editor's note: Later discussion on the SG16 mailing list revealed that it is possible on POSIX systems
    to retrieve the locale dependent encoding known at program startup time regardless of intervening calls
    to `setlocale()` with code like:
    ```
     locale_t loc = newlocale(LC_CTYPE_MASK, "", (locale_t)0);
     const char* name = nl_langinfo_l(CODESET, loc);
     ...
     freelocale(loc); 
    ```
    \]
  - Hubert suggested that programmers can collect this information on their own and that they should be aware if
    some library is calling `setlocale()` before `main()` is invoked.
  - Tom agreed, but stated that doing so is hard in practice, particularly for library authors.
  - JeanHeyd observed that the C library behavior depends on the currently set locale and asked what benefit
    is provided by `test_encoding::system()` if it's not in sync with the C and C++ libraries.
  - Tom responded that it indicates what encoding is expected for I/O outside of the process.
- Tom confirmed that the next meeting will be on February 5th and that it will be the last meeting before we
  meet in Prague.


# January 8th, 2020

## Draft agenda:
- LWG issue 3341: basic_regex range constructor: Missing requirements for iterator types
  - https://cplusplus.github.io/LWG/issue3341
  - Billy O'Neal copied SG16 on this issue; see https://lists.isocpp.org/sg16/2019/12/0990.php
  - What should be the proposed resolution?
- P1949: C++ Identifier Syntax using Unicode Standard Annex 31:
  - https://wg21.link/p1949
  - Which UAX #31 requirements do we intend to satisfy (see section 2)?
  - Which UAX #31 specific character adjustments do we want (see section 2.4)?
  - Which UAX #31 NFKC modifications we we want (see section 5.1)?

## Meeting summary:
- Attendees:
  - David Wendt
  - JeanHeyd Meneide
  - Lyberta
  - Peter Bindels
  - Steve Downey
  - Tom Honermann
  - Zach Laine
- LWG issue 3341: basic_regex range constructor: Missing requirements for iterator types
  - https://cplusplus.github.io/LWG/issue3341
  - Tom introduced the topic:
    - Billy O'Neal copied SG16 on this issue.  His email is available in the SG16 mailing list archives
      at https://lists.isocpp.org/sg16/2019/12/0990.php.
    - What should be the proposed resolution?
  - Zach asked why we should be concerned about this issue.
  - Tom responded that Billy copied us on it, presumably seeking our input.
  - Zach stated that implicit transcoding should not occur; The safest thing to do would be to require
    `ForwardIterator::value_type` to be exactly `charT`.
  - JeanHeyd agreed with the no implicit transcoding stance; that would make `std:regex` even slower!
  - Peter chimed in via chat agreeing with an exact type requirement and the following constraint:
    - `std::is_same_t<value_type, decltype(*std::declval<ForwardIterator>()>`
  - Peter asked if we should enable views to be used as inputs.
  - Steve stated that would be a more difficult challenge given the recent difficulties faced when
    attempting to add range constructors for standard containers.
  - Zach agreed that adding range support could be difficult and is out of scope for this issue anyway.
  - Peter concurred and noted that view support can always be added later.
  - Tom observed that if a same type constraint is added, then SFINAE will kick in, but it might be
    preferred to make it a hard error if the iterator value type doesn't match.
  - Zach suggested leaving that for LWG to decide.
  - Tom agreed and stated he would respond to Billy's email and LWG with our thoughts.
- P1949: C++ Identifier Syntax using Unicode Standard Annex 31:
  - https://wg21.link/p1949
  - https://github.com/cplusplus/nbballot/issues/28
  - Tom introduced the topic.
    - In Belfast, EWG did not accept
      [SG16's recommended resolution for NL029](http://wiki.edg.com/bin/view/Wg21belfast/SG16NBNL029)
      for C++20.
    - Tom volunteered to submit a core issue for C++20 in order to allow us to resolve the concern as
      a defect, but he doesn't have a PR to propose.
    - Tom is thinking about bailing on submitting that core issue, but thought he would check if SG16
      might have consensus on what solution we would want.  In particular, if we were to adopt
      [UAX #31](https://www.unicode.org/reports/tr31/tr31-31.html), what would be our answers to these
      questions?
      - Which UAX #31 requirements do we intend to satisfy (see section 2)?
      - Which UAX #31 specific character adjustments do we want (see section 2.4)?
      - Which UAX #31 NFKC modifications we we want (see section 5.1)?
  - Zach suggested we skip C++20 and just proceed with addressing this for C++23.
  - Steve provided motivation for dealing with this as a DR; some compilers are just starting to allow
    extended characters in identifiers.  Previously, programmers had to go out of their way to create
    weird identifiers.  Clang has allowed extended characters forever (since Clang 3.3 or so), gcc
    support was added for gcc 10.  The window for changing behavior is shrinking.
  - Zach asked if the concern was about breaking existing code given that this isn't the kind of break
    we usually worry too much about.
  - Tom replied that the breakage could be silent if Unicode normalization affects whether two
    identifiers match.
  - Steve added that breakage could occur due to excluded characters like the poop emoji.  Compilers
    could provide backward compatibility options; Hyrum's law.
  - Steve continued stating that, if we don't get this nailed down for C++23, we could probably still
    do it because it probably won't affect that much code.
  - Zach observed that the impact would mostly be due to banning emoji.
  - Steve agreed; emoji is the only case people are likely to notice.  Programmers aren't likely to
    want right-to-left characters in identifiers for example.
  - Which UAX #31 requirements do we intend to satisfy (see section 2)?
    - Tom stated that we need to choose whether to use the `ID_Start`/`ID_Continue` or
      `XID_Start`/`XID_Continue` properties to define identifier syntax.  P1949 suggests using the
      `XID_Start`/`XID_Continue` variants and doing so is necessary to meet the requirements for
      [UAX31-R1](https://www.unicode.org/reports/tr31/tr31-31.html#R1) without defining a profile;
      though, we'll need a profile to add `_` as a start character.
    - Steve recommended we adopt the XID variants and add `_` as a start character.  However, this
      doesn't suffice to guarantee identifier stability.
    - Tom stated that, in order to meet requirement
      [UAX31-R1a](https://www.unicode.org/reports/tr31/tr31-31.html#R1a), that he thinks we'll need
      to specify additional characters to exclude.  The NL029 NB comment specified a particular range
      to exclude, but he is not sure if or how that matches UAX31.
    - Steve corrected Tom's interpretation; that requirement allows opting in to characters that are
      disallowed by default.
    - Peter stated that section 2.3 explains that some character that are restricted by default are
      needed in some cases for some scripts.
    - Peter continued stating that he thinks we lack the experience to make choices in this regard and
      suggested we proceed with more restrictions now and relax them later based on experience and
      motivation.
    - Tom asked about meeting the requirements for
      [UAX31-R1b](https://www.unicode.org/reports/tr31/tr31-31.html#R1b); assuming we want to meet
      that requirement, how would we do so?
    - Steve responded that, given ABI issues, we should commit to meeting this requirement.  In
      practice, that means that, for example, if a future Unicode standard were to remove characters
      from `XID_CONTINUE`, that we would update our profile to add them back in.
    - Peter asked if the `XID_Start`/`XID_Continue` properties are stable.
    - Zach responded that he understood them to be stable.
    - Steve responded that they are derived properties and are not guaranteed to be stable, but
      probably will be in practice.  \[Editor's note: in later email discussion, Steve offered a
      correction to this statement: `XID_Start` and `XID_Continue` are guaranteed stable, just not
      immutable. Immutability is the property that things that are not identifiers remain not
      identifiers. \]
    - Zach mentioned that he wasn't previously aware that UAX31 had options, but it seems our goal
      now needs to be to identify the options, select them, and then make sure proposed wording
      reflects our intent.
    - Tom agreed.
  - Which UAX #31 specific character adjustments do we want (see section 2.4)?
    - Peter, reviewing section 2.4, stated no observed need for exceptions other than for `_` in
      the start position; a choice that is already explicitly listed as an option.
  - Which UAX #31 NFKC modifications we we want (see section 5.1)?
    - Tom stated that we need to figure out how to deal with normalization if we want stable
      identifiers.
    - Zach provided some background on NFC, NFD, compatibility, comparisons, and conversions.
    - Zach professed support for standardizing on NFC; NFD is not really usable since combining
      marks don't tend to be represented by themselves in identifiers.
    - Tom asked if standardizing on NFC commits implementors to perform normalization.
    - Steve responded that gcc 10 already emits a warning for identifiers that are written in
      non-NFC forms in source code.
    - Zach stated that checking for NFC is fast, at least for common cases, so diagnosing is
      reasonable, but stating that non-NFC identifiers are IFNDR (ill-formed no diagnostic required)
      is also a possibility.
    - Tom observed that conversions from other character sets like Windows-1252 probably always
      result in NFC.
    - Zach agreed noting that such conversion is probably done via the compiler's internal encoding.
    - Peter stated that there are other character sets that have combining marks, but none of those
      are probably supported by compilers.
    - Tom, considering source code that is encoded as UTF-8 in NFD, asked if requiring NFC could be
      problematic for existing editors and tools.
    - Steve observed that this issue already exists and that tools today already expect NFC.
    - Peter recommended that we make use of non-NFC normalized source code IFNDR and encourage tools
      to diagnose violations.
    - Zach responded that IFNDR is generally reserved for cases where something can't be reasonably
      diagnosed; since diagnosis is reasonable here, non-NFC forms should be considered ill-formed.
    - Steve added that compiler implementors can support options to relax NFC checking.
    - Tom noted that this creates a specification issue since, if source encoding is not UTF-8, it
      needs to be transcoded to NFC, but if it is UTF-8, source code needs to already be in NFC.
    - Zach responded that we don't have to; we just specify the characters that are valid based on
      `XID_Start`/`XID_Continue`.
    - Steve added that the NFC check has to be done after conversion from source encoding to internal
      encoding and that he is unaware of any encoding that does not naturally transcode to NFC.
    - Peter observed that combining diacritics are part of `XID_Continue` and that there are
      therefore two spellings of café; a 4 code point variant using
      U+00E9 {LATIN SMALL LETTER E WITH ACUTE} and a 5 code point variant using
      U+0301 {COMBINING ACUTE ACCENT}.
    - Zach stated that this feature requires the compiler's internal encoding to be Unicode.
    - Tom responded that, since C++11, the internal encoding must already be isomorphic to Unicode.
    - Zach suggested that both forms of café should not be allowed; that NFC should be required, and
      that use of combining characters should be disallowed in our profile.
    - Steve responded that disallowing all combining characters probably isn't feasible; there aren't
      precomposed forms of all characters; in NFC, combining characters will still appear, but only
      when they are actually required.
    - Zach suggested this is a restriction that could be relaxed later.
    - Steve observed that this would make specification of the profile more difficult.
    - Zach agreed and suggested just specifying a list of start and continue characters; this avoids
      implementors having to do hard things.
    - Peter noticed a problem with that approach; new Unicode characters could not be used unless and
      until the standard is updated with a new list of start/continue characters.
    - Tom added that this is why we want to defer to the implementation-defined Unicode version.
    - Steve added this is also why we want the identifier stability guarantee; otherwise we get
      linkage problems.
    - Peter suggested it should be ok to define a profile with `<Start>` defined as `XID_Start` + '_',
      and `<Continue>` defined as `XID_Continue` - <all_combining_characters>.
    - Steve noted that we have a floating Unicode reference today.
    - Tom agreed but noted that we have not yet required implementors to state which version of Unicode
      they conform to.
    - Steve agreed and added that, technically, we only have a floating reference to ISO/IEC 10646; this
      may not cover the normalization algorithm.
    - Steve summarized some options; there are two ways to deal with NFC: 1) source must be NFC normalized,
      and 2) the compiler internal encoding must be NFC.  Not allowing combining characters gives us the
      stability that we need without having to distinguish between those options.
    - Steve continued that omitting combining characters avoids the problem of Unicode introducing new
      precomposed characters that previously had to be represented with a combining character thereby
      changing NFC.
    - Tom responded that he thought the Unicode standard has a stability guarantee that new precomposed
      characters will not be introduced.
    - Peter observed that allowing combining characters is therefore required for new characters.
    - Tom suggested we need to do some more research.
    - Steve, after checking the Unicode standard, reported that normalization forms are guaranteed to be
      stable.
    - Zach quoted from section 3 of [UAX #15](https://www.unicode.org/reports/tr15/tr15-48.html):
      - "It is crucial that Normalization Forms remain stable over time. That is, if a string that does
        not have any unassigned characters is normalized under one version of Unicode, it must remain
        normalized under all future versions of Unicode."
    - Peter repeated his guidance that combining characters must be allowed in order to support some
      scripts.
    - Tom agreed and acknowledged that we probably therefore need to require NFC.
    - Tom summarized options identified so far:
      - 1) The compiler converts to NFC internally.  This could technically break some existing code.
      - 2) Require UTF encoded source files to be NFC and that non-UTF encoded source files be transcoded
           (noting that we believe that transcoding from any existing character sets will produce NFC).
    - Zach observed that the implementation effort is equivalent for those cases since an NFC check can
      bail out early if the check fails, but is otherwise same amount of work so that the complexity cost
      is the same.
    - Steve stated that he may not be in Prague, but that others can champion the paper as needed.
    - Peter and Zach both volunteered to champion.
    - Steve stated he would try to get an updated revision submitted for the Prague pre-meeting mailing.
- Tom stated that the next meeting will be January 22nd.


# December 11th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#december-11th-2019.


# November 20th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#november-20th-2019.


# October 23rd, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#october-23rd-2019.


# October 9th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#october-9th-2019.


# September 25th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#september-25th-2019.


# September 4th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#september-4th-2019.


# August 21st, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#august-21st-2019.


# July 31st, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#july-31st-2019.


# June 26th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#june-26th-2019.


# June 12th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#june-12th-2019.


# May 22nd, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#may-22nd-2019.


# May 15th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#may-15th-2019.


# April 24th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#april-24th-2019.


# April 10th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#april-10th-2019.


# March 27th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#march-27th-2019.


# March 13th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#march-13th-2019.


# February 13th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#february-13th-2019.


# January 23rd, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#january-23rd-2019.


# January 9th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2019.md#january-9th-2019.


# December 19th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-19th-2018.


# December 5th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-5th-2018.


# October 17th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-17th-2018.


# October 3rd, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-3rd-2018.


# August 29th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#august-29th-2018.


# July 25th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-25th-2018.


# July 11th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-11th-2018.


# June 20th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-20th-2018.


# May 30th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-30th-2018.


# May 16th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-16th-2018.


# April 25th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-25th-2018.


# April 11th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-11th-2018.


# March 28th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-28th-2018.


# Prior std-text-wg meetings

Meetings held by the informal std-text-wg working group prior to the
formation of SG16 are available at:
- https://github.com/tahonermann/std-text-wg/blob/master/MeetingNotes.md
